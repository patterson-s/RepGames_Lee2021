---
title: "replication_LEE2021"
output: html_document
date: "2023-06-14"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


# Library 

## Issues: 
The `doStata` package is old and does not appear to be maintained or have much documentation. It also does not load on newer versions of R. 

Is there a better package that is more commonly used? 

It actually doesn't appear necessary for the project. 

```{r Library}

pacman::p_load(statar, doStata, tidyverse, stargazer, scales, cowplot, xtable)

```

# Load data 
## Issues: PASSING
```{r}
#### Read-in ####
df_original <- read.csv("C:/Users/spatt/Desktop/replicationworkshop/Public_access_datafile_APSR_Lee_2021.csv",stringsAsFactors = F)
```


# Pre-processing
## Issues: This would benefit from high level annotation (describing the general purpose) and in-context annotation (comments in code). Should avoid droppingin a massive block of code

```{r}
### Pre-processing, df ####
df <- df_original %>%
  # Re-labeling the 'issue' variable and converting it into a factor with specific levels
  mutate(issue = ifelse(issue=="GMO","GMO Ban",issue),
         issue = ifelse(issue=="RC","Rent Control",issue),
         issue = ifelse(issue=="NEP","Needle Exchange",issue),
         issue = factor(issue,levels = c("Needle Exchange","GMO Ban","Rent Control")),

         # Creating binary versions of the 'preference' and 'policy' variables
         preference_bin = ifelse(preference>0.5,1,0),
         policy_bin = ifelse(preference>0.5,1,0),

         # Creating three-level versions of the 'preference' variable
         preference_3 = ifelse(preference>0.5,1,0),
         preference_3 = ifelse(preference==0.5,0.5,preference_3),
         preference_3 = ifelse(preference<0.5,0,preference_3),

         # Creating binary and three-level versions of the 'accuracy' variable
         accuracy_3 = ifelse(accuracy>0.5,1,0),
         accuracy_bin = ifelse(accuracy>0.5,1,0),
         accuracy_3 = ifelse(accuracy==0.5,0.5,accuracy_3),
         accuracy_3 = ifelse(accuracy<0.5,0,accuracy_3),

         # Recoding 'female' variable into 'gender'
         gender=  ifelse(female==1,"Women","Men"),

         # Creating age bins based on median age
         age_bin=  cut(age, breaks= quantile(age,probs = seq(0,1,1/2),na.rm = T),
                       labels=c("Younger","Older")),
         age_cat = ifelse(age >= 18 & age <= 35, "18-35", NA),
         age_cat = ifelse(age >= 36 & age <= 45, "36-45", age_cat),
         age_cat = ifelse(age >= 46 & age <= 55, "18-35", age_cat),
         age_cat = ifelse(age >= 56 & age <= 65, "56-65", age_cat),
         age_cat = ifelse(age >= 56 & age <= 65, "56-65", age_cat),
         age_cat = ifelse(age >  65, "65+", age_cat),

         # Creating government experience bins based on median experience
         exp_bin=  cut(gov_exp, breaks= quantile(gov_exp,probs = seq(0,1,1/2),na.rm = T),
                       labels=c("Less experience","More experience")),

         # Creating a polarization variable based on difference between 'republican_alignment' and 'democrat_alignment'
         polarization = republican_alignment - democrat_alignment,

         # Recoding ideological alignment into 'moderate' and 'conservative' variables
         moderate = ifelse(ideo5=="Moderate, middle of the road",1,0),
         conservative = ifelse(ideo5%in%c("Somewhat conservative","Very conservative"),1,0),

         # Recoding political party identification into 'republican' variable
         republican = ifelse(pid_3=="Republican",1,NA),
         republican = ifelse(!is.na(pid_indep)&pid_indep=="Republican Party",1,republican),
         republican = ifelse(pid_3=="Democrat",0,republican),
         republican = ifelse(!is.na(pid_indep)&pid_indep=="Democratic Party",0,republican),

         # Creating 'republican_alignment' and 'democrat_alignment' variables based on specific statements in 'partisan_diss'
         republican_alignment <- ifelse(partisan_diss %in% c("Democrats are more likely to support rent control","Democrats are more likely to support a GMO ban","Republicans are more likely to support the use of needle exchanges"),1,0),
         democrat_alignment <- ifelse(partisan_diss %in% c("Republicans are more likely to support rent control","Republicans are more likely to support a GMO ban","Democrats are more likely to support the use of needle exchanges"),1,0),

         # Recoding 'republican' variable into 'party_bin' factor
         party_bin = factor(ifelse(republican==1,"Republican","Democrat")),

         # Adding a 'policymaker' variable (presumably to signify that all respondents are policymakers)
         policymaker = 1,

         # Adding a 'survey' variable (presumably to indicate the survey code)
         survey = "CP18")


# Converting 'familiarity' into numeric and recoding into 'familiarity_3' (three-level) and 'familiarity_bin' (binary) variables
df$familiarity <- as.numeric(df$familiarity)
df$familiarity_3 <- ifelse(df$familiarity==1,1,NA)
df$familiarity_3 <- ifelse(df$familiarity==0.67,0.5,df$familiarity_3)
df$familiarity_3 <- ifelse(df$familiarity==0.33,0,df$familiarity_3)
df$familiarity_3 <- ifelse(df$familiarity==0,0,df$familiarity_3)
df$familiarity_bin <- ifelse(df$familiarity_3==0,0,1)

# Defining levels for 'preference_3' 
a <- "Least\nCongruent"
b <- "Somewhat\nCongruent"
c <- "Most\nCongruent"
df$preference_3_level <- ifelse(df$preference > 0.5, c,"")
df$preference_3_level <- ifelse(df$preference == 0.5,b,df$preference_3_level)
df$preference_3_level <- ifelse(df$preference < 0.5, a,df$preference_3_level)
df$preference_3_level <- factor(df$preference_3_level, levels = c(a,b,c))

# Defining levels for 'accuracy_3' 
a <- "Least\nAccurate"
b <- "Somewhat\nAccurate"
c <- "Most\nAccurate"
df$accuracy_3_level <- ifelse(df$accuracy > 0.5, c,"")
df$accuracy_3_level <- ifelse(df$accuracy == 0.5,b,df$accuracy_3_level)
df$accuracy_3_level <- ifelse(df$accuracy < 0.5, a,df$accuracy_3_level)
df$accuracy_3_level <- factor(df$accuracy_3_level, levels = c(a,b,c))

# Creating 'accuracy_posterior' by adding 'accuracy' and 'accuracy_response', and recoding into 'accuracy_response_bin'
df$accuracy_posterior <- df$accuracy + df$accuracy_response
df$accuracy_response_bin = ifelse(df$accuracy_posterior>0.5&df$accuracy<0.51,1,NA)
df$accuracy_response_bin = ifelse(df$accuracy_posterior>0.5&df$accuracy>0.5,0,df$accuracy_response_bin)
df$accuracy_response_bin = ifelse(df$accuracy_posterior<0.51&df$accuracy<0.51,0,df$accuracy_response_bin)
df$accuracy_response_bin = ifelse(df$accuracy_posterior<0.51&df$accuracy>0.51,0,df$accuracy_response_bin)

# Creating 'preference_posterior' by adding 'preference' and 'preference_response', and recoding into 'preference_response_bin'
df$preference_posterior <- df$preference + df$preference_response
df$preference_response_bin = ifelse(df$preference_posterior>0.5&df$preference<0.51,1,NA)
df$preference_response_bin = ifelse(df$preference_posterior>0.5&df$preference>0.51,0,df$preference_response_bin)
df$preference_response_bin = ifelse(df$preference_posterior<0.51&df$preference<0.51,0,df$preference_response_bin)
df$preference_response_bin = ifelse(df$preference_posterior<0.51&df$preference>0.51,0,df$preference_response_bin)

# ISSUE Creating a binary 'bias_num' variable from 'bias' ----
## This variable already exists in the submitted dataset as "partisan_bias"

#df$bias_num <- ifelse(df$bias == "Unbiased",1,0)



# Recoding 'decision_factors_decision_factors_experts' into numeric, ranging from 0 to 1
df[,"decision_factors_decision_factors_experts"] = ifelse(df[,"decision_factors_decision_factors_experts"]=="Extremely important","1",df[,"decision_factors_decision_factors_experts"])
df[,"decision_factors_decision_factors_experts"] = ifelse(df[,"decision_factors_decision_factors_experts"]=="Very important","0.75",df[,"decision_factors_decision_factors_experts"])
df[,"decision_factors_decision_factors_experts"] = ifelse(df[,"decision_factors_decision_factors_experts"]=="Moderately important","0.5",df[,"decision_factors_decision_factors_experts"])
df[,"decision_factors_decision_factors_experts"] = ifelse(df[,"decision_factors_decision_factors_experts"]=="Slightly important","0.25",df[,"decision_factors_decision_factors_experts"])
df[,"decision_factors_decision_factors_experts"] = as.numeric(ifelse(df[,"decision_factors_decision_factors_experts"]=="Not at all important","0",df[,"decision_factors_decision_factors_experts"]))

# Creating a 'deference_num' binary variable from 'decision_factors_decision_factors_experts', and recoding it into 'deference' with levels 'High deference' and 'Low deference'
df$deference_num=ifelse(df$decision_factors_decision_factors_experts>0.25,1,0)
df$deference =ifelse(df$deference_num == 1,"High deference",NA)
df$deference =ifelse(df$deference_num == 0,"Low deference",NA)

# Creating a subset of original dataframe where 'treated' equals 0
panel_control <- df[df$treated==0,]

# Creating a new dataframe 'panel_treated' from 'panel_control' by mutating 'accuracy' and 'preference' to account for response, and setting 'treated' to 1
panel_treated <- panel_control %>%
  mutate(accuracy = accuracy + accuracy_response,
         preference = preference + preference_response,
         treated=1)

# Combining 'panel_treated' and 'panel_control' to create a stacked dataframe 'panel_stacked' and adding a new column 'method' with value 'Within-\nsubject'
panel_stacked <- rbind(panel_treated,panel_control)
panel_stacked$method = "Within-\nsubject"

# Adding a new column 'method' to 'df' with value 'Across-\nsubject'
df$method = "Across-\nsubject"

# Combining 'df' and 'panel_stacked' into a new dataframe 'combined'
combined = rbind(df, panel_stacked)

```


# Figure 1

```{r}

# Start with the original dataframe
results <- df %>%
  # Filter out rows where 'treated' is not 0 and 'policymaker' is not 1
  filter(treated==0 & policymaker==1) %>%
  # Mutate 'party_bin' column to character type with "Rep. respondents" where 'republican' equals 1 and "Dem. respondents" otherwise
  mutate(party_bin = as.character(ifelse(republican == 1,"Rep. respondents","Dem. respondents")),
         # Convert 'party_bin' to a factor and specify the order of the levels
         party_bin = factor(party_bin,levels = c("Rep. respondents","Dem. respondents"))) %>%
  # Select 'policy_bin', 'party_bin', and 'issue' columns
  select(policy_bin, party_bin, issue) %>%
  # Filter out rows where 'issue', 'policy_bin', or 'party_bin' is NA
  filter(!is.na(issue) & !is.na(policy_bin) & !is.na(party_bin)) %>%
  # Group by 'party_bin' and 'issue'
  group_by(party_bin, issue) %>%
  # Summarize 'policy_bin' to calculate mean, standard deviation, and count of non-NA values
  summarise(mean = mean(policy_bin, na.rm = TRUE),
            sd   = sd(policy_bin, na.rm = TRUE),
            n    = sum(!is.na(policy_bin)))

# Calculate standard error (se) and confidence interval (ci)
results$se = results$sd/sqrt(results$n)
results$ci = results$se*1.96


figure1 <- ggplot(data=results, aes(fill= party_bin, y=mean, x=issue)) +
  geom_bar(width = 0.5, position='dodge', stat='identity')+
  geom_errorbar(aes(ymin=mean - ci,ymax=mean + ci), width=0.15, colour="gray48", position = position_dodge(width = 0.5)) +
  scale_fill_manual(values = c("firebrick","cornflowerblue"),guide=guide_legend(title=NULL))+
  geom_text(aes(label=mean), position=position_dodge(width=0.9), vjust=5.5, size=4)+
  theme(plot.title = element_text(hjust = 0.5),legend.position = "none")+
  xlab('')+ 
  ylab('')+
  ggtitle("")+
  scale_y_continuous(labels = percent) +
  scale_x_discrete(labels = c("Support\nNeedle Exchange","Oppose\nGMO Ban","Oppose\nRent Control"))+
  theme(legend.position = "right") + 
  theme_minimal()

```

# Figure 2

```{r}

# Create linear regression models for each 'issue' type, for both 'accuracy' and 'preference' as response variables
reg1b <- lm(accuracy ~ treated, d = df[df$survey == "CP18" & df$policymaker == 1 & df$issue == "Needle Exchange",])
reg2b <- lm(accuracy ~ treated, d = df[df$survey == "CP18" & df$policymaker == 1 & df$issue == "GMO Ban",])
reg3b <- lm(accuracy ~ treated, d = df[df$survey == "CP18" & df$policymaker == 1 & df$issue == "Rent Control",])
reg1p <- lm(preference ~ treated, d = df[df$survey == "CP18" & df$policymaker == 1 & df$issue == "Needle Exchange",])
reg2p <- lm(preference ~ treated, d = df[df$survey == "CP18" & df$policymaker == 1 & df$issue == "GMO Ban",])
reg3p <- lm(preference ~ treated, d = df[df$survey == "CP18" & df$policymaker == 1 & df$issue == "Rent Control",])

# Define function to create a plot of treatment effect
fig_effect = function(reg_effect, range, ylabel, subtitle, maintitle) {
  coeffs_effect = as.data.frame(summary(reg_effect)$coefficient)  # get coefficients from the regression model
  vcov_effect = vcov(reg_effect)  # get variance-covariance matrix from the model
  results = as.data.frame(matrix(, 1, 3))  # create empty data frame
  colnames(results) = c("mean", "se", "ci")  # name columns
  
  # fill in data frame with coefficients, standard error, and confidence interval
  results[,"mean"] <- coeffs_effect["treated", "Estimate"]
  results[,"se"] <- coeffs_effect["treated", "Std. Error"]
  results$ci <- results$se * 1.96
  
  # generate plot with mean treatment effect and confidence intervals
  p <- ggplot(data = results, aes(y = mean, x = "")) +
    geom_point(stat = 'identity', size = 0.5) +
    geom_errorbar(aes(ymin = mean - ci, ymax = mean + ci), width = 0.05) +
    labs(y = ylabel, subtitle = subtitle, title = maintitle) +
    geom_hline(yintercept = 0, lty = 3) +
    theme_minimal() +
    scale_y_continuous(breaks = c(-0.05, 0, 0.05, 0.1, 0.15, 0.2), limits = range,
                       labels = c("", "0%-pts", "", "10%-pts", "", "20%-pts")) +
    theme(legend.position = "none", axis.title.x = element_blank(),
          plot.subtitle = element_text(face = "plain", size = 9, hjust = 0.5),
          axis.title.y = element_text(size = 8),
          axis.text.y = element_text(size = 8),
          axis.text.x = element_text(size = 9),
          axis.ticks.x = element_blank(),
          plot.title = element_text(face = 'bold', hjust = 0.5, size = 12))
  return(p)
}

# Generate and combine individual plots for beliefs and preferences for each issue
beliefs = plot_grid(fig_effect(reg1b, range, "Δ Accuracy", "Belief about Experts", "Needle Exchange"),
                    fig_effect(reg2b, range, "Δ Accuracy", "Belief about Experts", "GMO Ban"),
                    fig_effect(reg3b, range, "Δ Accuracy", "Belief about Experts", "Rent Control"), ncol = 1)

preference = plot_grid(fig_effect(reg1p, range, "Δ Congruence", "Policy Preference", "Needle Exchange"),
                       fig_effect(reg2p, range, "Δ Congruence", "Policy Preference", "GMO Ban"),
                       fig_effect(reg3p, range, "Δ Congruence", "Policy Preference", "Rent Control"), ncol = 1)

# Combine belief and preference plots side-by-side
p <- plot_grid(beliefs, preference, ncol = 2, rel_widths  = c(1, 1))

figure2 <- p

```


# Figure 3

```{r}
# Define the range for the y-axis in the plots
range <- c(-.09,.25)

# Create six different regression models for each 'issue' type, for both 'accuracy' and 'preference' as response variables,
# and also include interaction between 'treated' and 'republican'
reg1b <- lm(accuracy ~ treated * republican, d = df[df$survey == "CP18" & df$policymaker == 1 & df$issue == "Needle Exchange",])
reg2b <- lm(accuracy ~ treated * republican, d = df[df$survey == "CP18" & df$policymaker == 1 & df$issue == "GMO Ban",])
reg3b <- lm(accuracy ~ treated * republican, d = df[df$survey == "CP18" & df$policymaker == 1 & df$issue == "Rent Control",])
reg1p <- lm(preference ~ treated * republican, d = df[df$survey == "CP18" & df$policymaker == 1 & df$issue == "Needle Exchange",])
reg2p <- lm(preference ~ treated * republican, d = df[df$survey == "CP18" & df$policymaker == 1 & df$issue == "GMO Ban",])
reg3p <- lm(preference ~ treated * republican, d = df[df$survey == "CP18" & df$policymaker == 1 & df$issue == "Rent Control",])

# Define function to create a plot for each regression model, including separate effects for Democrats and Republicans
fig_effects_by_party = function(reg, range, ylabel, subtitle, maintitle) {
  coeffs = as.data.frame(summary(reg)$coefficient)  # get coefficients from the regression model
  vcov = vcov(reg)  # get variance-covariance matrix from the model
  results = as.data.frame(matrix(, 2, 3))  # create empty data frame
  colnames(results) = c("mean", "se", "ci")  # name columns
  rownames(results) = c("democrat", "republican")  # name rows

  # fill in data frame with coefficients, standard error, and confidence interval for Democrats and Republicans
  results["democrat", "mean"] <- coeffs["treated", "Estimate"]
  results["democrat", "se"] <- coeffs["treated", "Std. Error"]
  results["republican", "mean"] <- coeffs["treated", "Estimate"] + coeffs["treated:republican", "Estimate"]
  results["republican", "se"] <- sqrt((vcov["treated:republican", "treated:republican"] + vcov["treated", "treated"] + 2 * vcov["treated", "treated:republican"]))
  results$ci <- results$se * 1.96
  results$party = c("democrat", "republican")  # create a new column 'party'
  results$colour = c("cornflowerblue", "firebrick")  # create a new column 'colour'

  # generate plot with treatment effects and confidence intervals for Democrats and Republicans
  p <- ggplot(results, aes(y = mean, x = party, range = range, colour = party)) +
    geom_point(stat = 'identity') +
    geom_errorbar(aes(ymin = mean - ci, ymax = mean + ci), width = 0.05) +
    theme_minimal() +
    labs(y = ylabel, subtitle = subtitle, title = maintitle, x = "") +
    geom_hline(yintercept = 0, lty = 3) +
    scale_y_continuous(breaks = c(-0.05, 0, 0.05, 0.1, 0.15, 0.2), limits = range, labels = c("", "0%-pts", "", "10%-pts", "", "20%-pts")) +
    scale_colour_manual(values = results$colour) +
    theme(legend.position = "none", axis.title.x = element_blank(),
          plot.subtitle = element_text(face = "plain", size = 9, hjust = 0.5),
          axis.title.y = element_text(size = 8),
          axis.text.y = element_text(size = 8),
          axis.text.x = element_blank(),
          axis.ticks.x = element_blank(),
          plot.title = element_text(face = 'bold', hjust = 0.5, size = 12))
  return(p)
}

# Generate plots for belief and preference for each issue
beliefs = plot_grid(fig_effects_by_party(reg1b, range, "Δ Accuracy", "Belief about Experts", "Needle Exchange"),
                    fig_effects_by_party(reg2b, range, "Δ Accuracy", "Belief about Experts", "GMO Ban"),
                    fig_effects_by_party(reg3b, range, "Δ Accuracy", "Belief about Experts", "Rent Control"), ncol = 1)
prefs = plot_grid(fig_effects_by_party(reg1p, range, "Δ Congruence", "Policy Preference", "Needle Exchange"),
                  fig_effects_by_party(reg2p, range, "Δ Congruence", "Policy Preference", "GMO Ban"),
                  fig_effects_by_party(reg3p, range, "Δ Congruence", "Policy Preference", "Rent Control"), ncol = 1)

# Combine belief and preference plots side-by-side
p <- plot_grid(beliefs, prefs, ncol = 2, rel_widths = c(1, 1))

# Create a legend for the plot
legend <- get_legend(fig_effects_by_party(reg2p, range, "", "Policy Preferences", "GMO Ban") + theme(legend.justification = "center",
                                                                                                       legend.text = element_text(size = 11), legend.title = element_blank(),
                                                                                                       legend.background = element_rect(colour = 'white'),
                                                                                                       legend.position = "bottom") +
                       theme(legend.position = "bottom", legend.justification = 0.5) +
                       theme(legend.key.width = unit(2, "line")) +
                       theme(legend.text = element_text(margin = margin(r = 10, l = 10, unit = "pt"))))

# Combine the plot and the legend, and save to a file
plot_grid(p, legend, nrow = 2, rel_heights = c(7, 1)) 

figure3 <- plot_grid(p, legend, nrow = 2, rel_heights = c(7, 1))

```

# Figure 4

```{r}

# Define a function to generate a plot for belief updating by prior
fig_belief_updating_by_prior = function(reg,range,ylabel,subtitle,maintitle){
  # Obtain the coefficients and variance-covariance matrix from the regression model
  coeffs = as.data.frame(summary(reg)$coefficient)
  vcov = vcov(reg)

  # Initialize a data frame to store the results
  results = as.data.frame(matrix(,3,3))
  colnames(results) = c("mean","se","ci")
  results$accuracy_3_level = factor(levels(df$accuracy_3_level),levels = levels(df$accuracy_3_level))
  
  # Calculate the mean and standard error for each level of pre-treatment accuracy
  results[,"mean"] <- coeffs[,"Estimate"]
  results[,"se"] <- coeffs[,"Std. Error"]
  
  # Calculate the confidence interval for each level of pre-treatment accuracy
  results$ci <- results$se * 1.96
  
  # Generate the plot
  p <- ggplot(results, aes(y=mean,x=accuracy_3_level)) +
    geom_point(stat='identity',size=0.5)+
    geom_errorbar(aes(ymin = mean - ci,ymax = mean + ci),width = 0.05)+
    labs(y=ylabel, subtitle=subtitle,title=maintitle, x=  "Pre-treatment Accuracy") +
    theme(plot.title = element_text(face = 'plain',hjust = 0.5,size=12))+
    geom_hline(yintercept=0,lty=3)+
    theme_minimal()+
    theme(legend.position = "none",axis.title.x = element_blank(),
          plot.subtitle = element_text(face = "plain",size=9,hjust = 0.5),
          axis.title.y = element_text(size=8),
          axis.text.y = element_text(size=8),
          axis.text.x = element_text(size=8),
          plot.title = element_text(face = 'bold',hjust = 0.5,size=12))+
    scale_y_continuous(labels = c("","0%-pts","","30%-pts","","60%-pts"),
                       limits = range,breaks = c(-0.15,0,0.15,0.3,0.45,0.6))
  return(p)}

# Do the same for preference updating
fig_preference_updating_by_prior = function(reg,range,ylabel,subtitle,maintitle){
  # Similar to above, but for pre-treatment preference
  coeffs = as.data.frame(summary(reg)$coefficient)
  vcov = vcov(reg)
  results = as.data.frame(matrix(,3,3))
  colnames(results) = c("mean","se","ci")
  results$preference_3_level = factor(levels(df$preference_3_level),levels = levels(df$preference_3_level))
  results[,"mean"] <- coeffs[,"Estimate"]
  results[,"se"] <- coeffs[,"Std. Error"]
  results$ci <- results$se * 1.96
  
  # Generate the plot
  p <- ggplot(results, aes(y=mean,x=preference_3_level)) +
    geom_point(stat='identity',size=0.5)+
    geom_errorbar(aes(ymin = mean - ci,ymax = mean + ci),width = 0.05)+
    labs(y=ylabel, subtitle=subtitle,title=maintitle, x=  "Pre-treatment Congruence") +
    theme(plot.title = element_text(face = 'plain',hjust = 0.5,size=12))+
    geom_hline(yintercept=0,lty=3)+
    theme_minimal()+
    theme(legend.position = "none",axis.title.x = element_blank(),
          plot.subtitle = element_text(face = "plain",size=9,hjust = 0.5),
          axis.title.y = element_text(size=8),
          axis.text.y = element_text(size=8),
          axis.text.x = element_text(size=8),
          plot.title = element_text(face = 'bold',hjust = 0.5,size=12))+
    scale_y_continuous(limits = range, breaks = c(-0.05,0,0.05,0.1,0.15,0.2),
                       labels = c("","0%-pts","","10%-pts","","20%-pts"))
  return(p)}

# Run separate regression models for each issue and response variable
reg1b <- lm(accuracy_response ~ accuracy_3_level -1 , d=df[df$survey=="CP18"&df$policymaker==1&df$issue=="Needle Exchange",])
reg2b <- lm(accuracy_response ~ accuracy_3_level -1, d=df[df$survey=="CP18"&df$policymaker==1&df$issue=="GMO Ban",])
reg3b <- lm(accuracy_response ~ accuracy_3_level - 1, d=df[df$survey=="CP18"&df$policymaker==1&df$issue=="Rent Control",])
reg1p <- lm(preference_response ~ preference_3_level -1 , d=df[df$survey=="CP18"&df$policymaker==1&df$issue=="Needle Exchange",])
reg2p <- lm(preference_response ~ preference_3_level -1, d=df[df$survey=="CP18"&df$policymaker==1&df$issue=="GMO Ban",])
reg3p <- lm(preference_response ~ preference_3_level - 1, d=df[df$survey=="CP18"&df$policymaker==1&df$issue=="Rent Control",])

# Define the ranges for the y-axis of the plots
range_b <- c(-.15,.6)
range_p <- c(-.05,.2)

# Generate the plots for beliefs and preferences
beliefs = plot_grid(fig_belief_updating_by_prior(reg1b,range_b,"Δ Accuracy","Belief about Experts","Needle Exchange"),
                    fig_belief_updating_by_prior(reg2b,range_b,"Δ Accuracy","Belief about Experts","GMO Ban"),
                    fig_belief_updating_by_prior(reg3b,range_b,"Δ Accuracy","Belief about Experts","Rent Control"),ncol=1)

prefs = plot_grid(fig_preference_updating_by_prior(reg1p,range_p,"Δ Congruence","Policy Preference","Needle Exchange"),
                  fig_preference_updating_by_prior(reg2p,range_p,"Δ Congruence","Policy Preference","GMO Ban"),
                  fig_preference_updating_by_prior(reg3p,range_p,"Δ Congruence","Policy Preference","Rent Control"),ncol=1)

# Combine the plots for beliefs and preferences into a single grid
p <- plot_grid(beliefs,prefs,ncol=2,rel_widths  = c(1,1))

# Save the grid of plots to a file
plot_grid(beliefs,prefs,ncol=2,rel_widths  = c(1,1))+ 
  ggsave("Figs/fig_updating_by_prior.png",unit = "in",width=7.5, height=6)

figure4 <- plot_grid(beliefs,prefs,ncol=2,rel_widths  = c(1,1))


```


# Supplementals 

```{r}
### DESCRIPTIVES BY POLICIES

## fig_bias #### ----
# The following lines of code are preprocessing the dataframe "df" by selecting specific columns, removing rows with NA values, and adding new columns
results <- df %>%
  select(bias_num, party_bin, issue) %>%
  filter(!is.na(issue) & !is.na(bias_num) & !is.na(party_bin)) %>%
  mutate(party_bin = as.character(ifelse(party_bin == "Republican","Rep. respondents","Dem. respondents")),
         party_bin = factor(party_bin,levels = c("Rep. respondents","Dem. respondents"))) %>%
  group_by(party_bin,issue) %>%
  summarise(mean = mean(bias_num, na.rm = TRUE),
            sd = sd(bias_num, na.rm = TRUE),
            n = sum(!is.na(bias_num)))

# Here, the code is calculating standard errors and confidence intervals based on the calculated mean and standard deviation
results$se = results$sd/sqrt(results$n)
results$ci = results$se*1.96

# Set the upper and lower limits for the error bars
limits <- aes(ymax = results$mean + results$ci, ymin=results$mean - results$ci)

# The following lines are creating a bar plot with error bars, and then saving it to a .png file
ggplot(data=results, aes(fill= party_bin, y=mean, x=issue)) +
  geom_bar(width = 0.5, position='dodge', stat='identity')+
  geom_errorbar(aes(ymin=mean - ci,ymax=mean + ci), width=0.15, colour="gray48", position = position_dodge(width = 0.5)) +
  scale_fill_manual(values = c("firebrick","cornflowerblue"),guide=guide_legend(title=NULL))+
  theme(plot.title = element_text(hjust = 0.5),legend.position = "none")+
  xlab('')+ 
  ylab('')+
  ggtitle("")+
  scale_y_continuous(labels = percent) +
  scale_x_discrete(labels = c("Experts on\nNeedle Exchange","Scientists on\nGMO Ban","Economists on\nRent Control"))+
  theme(legend.position = "right") + 
  theme_minimal()+
  ggsave("Figs/fig_bias.png", unit = "in",width=7.5, height=5,dpi = 600)

## fig_deference #### ----
# Preprocessing the dataframe "df" by selecting specific columns, removing rows with NA values, and creating and recoding new columns
results <- df %>%
  select(deference_num, party_bin, issue) %>%
  filter(!is.na(issue) & !is.na(deference_num) & !is.na(party_bin)) %>%
  mutate(party_bin = as.character(ifelse(party_bin == "Republican","Rep. respondents","Dem. respondents")),
         party_bin = factor(party_bin,levels = c("Rep. respondents","Dem. respondents"))) %>%
  group_by(party_bin,issue) %>%
  summarise(mean = mean(deference_num, na.rm = TRUE),
            sd = sd(deference_num, na.rm = TRUE),
            n = sum(!is.na(deference_num)))

# Calculating standard errors and confidence intervals based on the calculated mean and standard deviation
results$se = results$sd/sqrt(results$n)
results$ci = results$se*1.96
limits <- aes(ymax = results$mean + results$ci, ymin=results$mean - results$ci)

# Creating a bar plot with error bars, and saving it to a .png file
ggplot(data=results, aes(fill= party_bin, y=mean, x=issue)) +
  geom_bar(width = 0.5, position='dodge', stat='identity')+
  geom_errorbar(aes(ymin=mean - ci,ymax=mean + ci), width=0.15, colour="gray48", position = position_dodge(width = 0.5)) +
  scale_fill_manual(values = c("firebrick","cornflowerblue"),guide=guide_legend(title=NULL))+
  theme(plot.title = element_text(hjust = 0.5),legend.position = "none")+
  xlab('')+ 
  ylab('')+
  ggtitle("")+
  scale_y_continuous(labels = percent) +
  scale_x_discrete(labels = c("Experts on\nNeedle Exchange","Scientists on\nGMO Ban","Economists on\nRent Control"))+
  theme(legend.position = "right") + 
  theme_minimal()+
  ggsave("Figs/fig_deference.png", unit = "in",width=7.5, height=5,dpi = 600)

### fig_polarity #### ----
# Preprocessing the dataframe "df" by selecting specific columns, removing rows with NA values, and creating and recoding new columns
results <- df %>%
  select(polarization, party_bin, issue) %>%
  filter(!is.na(issue) & !is.na(polarization) & !is.na(party_bin)) %>%
  mutate(party_bin = as.character(ifelse(party_bin == "Republican","Rep. respondents","Dem. respondents")),
         party_bin = factor(party_bin,levels = c("Rep. respondents","Dem. respondents"))) %>%
  group_by(party_bin,issue) %>%
  summarise(mean = mean(polarization, na.rm = TRUE),
            sd = sd(polarization, na.rm = TRUE),
            n = sum(!is.na(polarization)))

# Calculating standard errors and confidence intervals based on the calculated mean and standard deviation
results$se = results$sd/sqrt(results$n)
results$ci = results$se*1.96
limits <- aes(ymax = results$mean + results$ci, ymin=results$mean - results$ci)

# Creating a bar plot with error bars, and saving it to a .png file
ggplot(data=results, aes(fill= party_bin, y=mean, x=issue)) +
  geom_bar(width = 0.5, position='dodge', stat='identity')+
  geom_errorbar(limits, width=0.3, colour="gray48", position = position_dodge(width = 0.6)) +
  scale_fill_manual(values = c("firebrick","cornflowerblue"),guide=guide_legend(title=NULL))+
  theme(plot.title = element_text(hjust = 0.5))+
  xlab('')+ 
  ylab('')+
  theme_minimal()+
  scale_y_continuous(labels = percent)+ 
  ggsave("Figs/fig_polarity.png", unit = "in",width=7.5, height=5)


```

# Alternate Visualizations

## Issue: this doesn't work; the authors didn't include the "preferences_GMO" variable, which prevents the entire figure. 

```{r}

#fig_levels ----

# Creating a plot for belief accuracy ----

## Policy: Needle Exchange ----

policy <- "Needle Exchange"
beliefs_NEP <- df %>%
  filter(survey=="CP18" & issue == policy & policymaker==1 & !is.na(accuracy) & !is.na(party_bin)) %>%
  select(treated, accuracy) %>%
  mutate(condition = factor(ifelse(treated == 1, "With expert evidence",
                                   "Without expert evidence"), 
                           levels = c("Without expert evidence","With expert evidence"))) %>%
  group_by(condition) %>%  
  summarise(count = n(), mean = mean(accuracy),
            se = sd(accuracy)/sqrt(count), ci = se * 1.96,
            lower = mean - ci, upper = mean + ci) %>%
  as.data.frame(.) %>%
  ggplot() + 
  aes(x=condition, y=mean, color=condition) + 
  geom_point(stat='identity', size=0.5, position = position_dodge(width=0.5)) +
  geom_errorbar(aes(ymin = lower, ymax = upper), width=0.2, position = position_dodge(width=0.5)) +
  theme_minimal() +
  scale_y_continuous(breaks = c(0,0.25,0.5,0.75,1), limits=c(0,1),
                     labels = c("Least accurate \n(<20% experts)", "", "", "", "Most accurate \n(>80% experts)")) +
  scale_color_manual(name = NULL, 
                     values = c("Without expert evidence" = "#006600",
                                "With expert evidence"  = "#660099")) +
  xlab("") + ylab("Belief") + 
  ggtitle(policy) +
  theme(legend.position = "none",
        axis.text.y = element_text(size=8),
        axis.title.y = element_text(size=11,vjust = -10,face = 'bold'),
        axis.text.x = element_blank(),
        axis.title.x = element_text(size=12),
        plot.title = element_text(face = 'bold', hjust = 0.5, size=11))

# Creating a plot for preference congruence
preferences_NEP <-  df %>%
  filter(survey=="CP18" & issue == policy & policymaker==1 & !is.na(preference) & !is.na(party_bin)) %>%
  select(party_bin, treated, preference) %>%
  mutate(condition = factor(ifelse(treated == 1,"With expert evidence",
                                   "Without expert evidence"), 
                           levels = c("Without expert evidence","With expert evidence"))) %>%
  group_by(condition) %>%  
  summarise(count = n(), mean = mean(preference),
            se = sd(preference)/sqrt(count), ci = se * 1.96,
            lower = mean - ci, upper = mean + ci) %>%
  as.data.frame(.) %>%
  ggplot() + 
  aes(x=condition, y=mean, color=condition) + 
  geom_point(stat='identity', size=0.5, position = position_dodge(width=0.5)) +
  geom_errorbar(aes(ymin = lower, ymax = upper), width=0.2, position = position_dodge(width=0.5)) +
  theme_minimal() +
  scale_y_continuous(breaks = c(0,1/6,2/6,3/6,4/6,5/6,6/6), limits=c(-0.01,1),
                     labels = c("Least congruent", "", "", "", "", "", "Most congruent")) +
  scale_color_manual(name = NULL, 
                     values = c("Without expert evidence" = "#006600",
                                "With expert evidence"  = "#660099")) +
  xlab("") + ylab("Preference") +
  theme(legend.position = "none",
        axis.text.y = element_text(size=8),
        axis.title.y = element_text(size=11, vjust = -10, face = 'bold'),
        axis.text.x = element_blank(),
        axis.title.x = element_text(size=12),
        plot.title = element_text(face = 'bold', hjust = 0.5, size=11))

# Policy: GMO Ban ----
policy <- "GMO Ban"
beliefs_GMO <- df %>%
  filter(survey=="CP18" & issue == policy & policymaker==1 & !is.na(accuracy) & !is.na(party_bin)) %>%
  select(party_bin, treated, accuracy) %>%
  mutate(condition = factor(ifelse(treated == 1, "With expert evidence",
                                   "Without expert evidence"), 
                           levels = c("Without expert evidence","With expert evidence"))) %>%
  group_by(condition) %>%
  summarise(count = n(), mean = mean(accuracy),
            se = sd(accuracy)/sqrt(count), ci = se * 1.96,
            lower = mean - ci, upper = mean + ci) %>%
  ggplot() + 
  aes(x=condition, y=mean, color=condition) + 
  geom_point(stat='identity', size=0.5, position = position_dodge(width=0.5)) +
  geom_errorbar(aes(ymin = lower, ymax = upper), width=0.2, position = position_dodge(width=0.5)) +
  theme_minimal() +
  scale_y_continuous(breaks = c(0,0.25,0.5,0.75,1), limits=c(0,1),
                     labels = c("","","","","")) +
  scale_color_manual(name = NULL, 
                     values = c("Without expert evidence" = "#006600",
                                "With expert evidence"  = "#660099")) +
  xlab("") + ylab("") + 
  ggtitle(policy) +
  theme(legend.position = "none",
        axis.text.y = element_text(size=8),
        axis.title.y = element_text(size=10, vjust = -10, face = 'bold'),
        axis.text.x = element_blank(),
        axis.title.x = element_text(size=10),
        plot.title = element_text(face = 'bold', hjust = 0.5, size=11))


# Policy: Rent Control ----
policy <- "Rent Control"
beliefs_RC <- df %>%
  filter(survey=="CP18" & issue == policy & policymaker==1 & !is.na(accuracy) & !is.na(party_bin)) %>%
  select(party_bin, treated, accuracy) %>%
  mutate(condition = factor(ifelse(treated == 1, "With expert evidence",
                                   "Without expert evidence"), 
                           levels = c("Without expert evidence","With expert evidence"))) %>%
  group_by(condition) %>%
  summarise(count = n(), mean = mean(accuracy),
            se = sd(accuracy)/sqrt(count), ci = se * 1.96,
            lower = mean - ci, upper = mean + ci) %>%
  ggplot() + 
  aes(x=condition, y=mean, color=condition) + 
  geom_point(stat='identity', size=0.5, position = position_dodge(width=0.5)) +
  geom_errorbar(aes(ymin = lower, ymax = upper), width=0.2, position = position_dodge(width=0.5)) +
  theme_minimal() +
  scale_y_continuous(breaks = c(0,0.25,0.5,0.75,1), limits=c(0,1),
                     labels = c("","","","","")) +
  scale_color_manual(name = NULL, 
                     values = c("Without expert evidence" = "#006600",
                                "With expert evidence"  = "#660099")) +
  xlab("") + ylab("") + 
  ggtitle(policy) +
  theme(legend.position = "none",
        axis.text.y = element_text(size=8),
        axis.title.y = element_text(size=10, vjust = -10, face = 'bold'),
        axis.text.x = element_blank(),
        axis.title.x = element_text(size=10),
        plot.title = element_text(face = 'bold', hjust = 0.5, size=11))

# Combine beliefs plot ----
# Combine beliefs plots horizontally
beliefs <- plot_grid(beliefs_NEP, beliefs_GMO, beliefs_RC, nrow=1, rel_widths = c(1.4, 1, 1))

# Combine preferences plots horizontally
preferences <- plot_grid(preferences_NEP, preferences_GMO, preferences_RC, nrow=1, rel_widths = c(1.4, 1, 1))

# Combine beliefs and preferences plots vertically
p <- plot_grid(beliefs, preferences, nrow=2, rel_heights = c(1, 0.91))

# Get the legend from beliefs_NEP plot and customize it
legend <- get_legend(beliefs_NEP + theme(legend.justification = "center",
                                         legend.text = element_text(size=10),
                                         legend.background = element_rect(colour = 'white'),
                                         legend.position = "bottom"))

# Combine the plot and the legend vertically
final_plot <- plot_grid(p, legend, nrow=2, rel_heights = c(7, 1))

# Print the final plot
print(final_plot)


```


# Subsample Analysis (within-subject)

```{r}

# Define the position variable based on the Staffer variable
panel_stacked$position = ifelse(panel_stacked$Staffer==0,"Elected Official",NA)
panel_stacked$position = ifelse(panel_stacked$Staffer==1,"Staffer",panel_stacked$position)
panel_stacked$position = factor(panel_stacked$position,levels = c("Elected Official","Staffer"))

# Create the beliefs data frame by filtering, selecting, and mutating the panel_stacked data frame
beliefs <-   panel_stacked %>%
  filter(survey=="CP18"&policymaker==1&!is.na(accuracy)&!is.na(position)) %>%
  select(position,treated,accuracy)%>%
  mutate(type = position,
         condition = factor(ifelse(treated == 1,"With expert evidence",
                                   "Without expert evidence"), levels = c("Without expert evidence","With expert evidence")))%>%
  group_by(condition,type) %>%  summarise(. ,count = n(),mean = mean(accuracy),
                                          se = sd(accuracy)/sqrt(count), ci   = se * 1.96,
                                          lower = mean - ci,upper = mean + ci)%>%
  as.data.frame(.)
# Plot the beliefs data


# Create the preferences data frame by filtering, selecting, and mutating the panel_stacked data frame
preferences <-     panel_stacked %>%
  filter(survey=="CP18"&policymaker==1&!is.na(preference)&!is.na(position)) %>%
  select(position,treated,preference)%>%
  mutate(type = position,
         condition = factor(ifelse(treated == 1,"With expert evidence",
                                   "Without expert evidence"), levels = c("Without expert evidence","With expert evidence")))%>%
  group_by(condition,type) %>%  summarise(. ,count = n(),mean = mean(preference),
                                          se = sd(preference)/sqrt(count), ci   = se * 1.96,
                                          lower = mean - ci,upper = mean + ci)%>%
  as.data.frame(.)

# Plot the preferences data

# Create a grid of the beliefs and preferences plots in a single row
p <- plot_grid(beliefs, preferences, nrow = 1, rel_widths = c(1.2, 1))

# Extract the legend from the beliefs plot
legend <- get_legend(beliefs + theme(legend.justification = "center",
                                     legend.text = element_text(size = 10),
                                     legend.background = element_rect(colour = 'white'),
                                     legend.position = "bottom"))

# Add the extracted legend to the combined plot and create a new combined plot with 2 rows
# The first row contains the original combined plot and the second row contains the legend
# The relative heights of the rows are set to 7 and 1 respectively
plot_grid(p, legend, nrow = 2, rel_heights = c(7, 1))



```





